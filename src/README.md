# 重构计划 (version 1.0)
## (一期计划) front重构
  1. 搭建支持jsp和SpringMVC的springboot框架，并整合swagger文档(JDK1.8+Springboot1.4.2.Release+ Maven3.6.1).
  2. 新建配置类，扫描加载旧系统中涉及spring配置的xml.
  3. 整合pom.xml，将旧系统中的依赖和插件整合到新项目中.
     - 依赖升级; 因旧项目中的依赖十分老旧; 移植的时候查询相关资料如果新版本的依赖向下兼容的话，可以直接升级版本为最新版.
     - 依赖替换; 项目中有一部分依赖已经无法下载，一部分原因是这些依赖都已经改名换姓换成了别的groupID以及artifactId.需要从maven官方库查找替换.
  4. 去除web.xml，将旧系统中web.xml相关内容全部整合到配置类里.
     - 涉及context-param、filter、listener、servlet、jsp-config等内容使用配置类替换.
  5. 拷贝webapp以及WEB-INF下的资源到新项目中对应位置.
  6. 替换Action为controller，首先拷贝替换修改action对应的父action。然后可以采用以下两种方式：
        1. 可以采用单人重构从struts.xml入手，找出include包含的所有struts-*相关的文件，逐个找到对应的action以及action配置的struts拦截器，
        进行重构(替换struts拦截器为SpringMVC拦截器，替换action为controller).
        2. 采用多人重构从包入手，旧front的action包大体分为app、cxg、nlr和web(nlr比较少，app最多);
         可以按照包进行职责分配，根据包中的action反向命中并解析对应的struts的xml配置。最后替换action和拦截器.
        3. 在代码移植修改的过程中会涉及到JDK升级报错问题; 可能需要修改对应的语法规范，但不能修改内部的逻辑; 涉及到公共依赖的部分需要协商修改.
        4. 注意事项: 在改造完一个action后必须要检测改造后的controller是否可以运行正常.
   7. 去除profile文件夹，将公共配置信息抽取到application.properties中，正式环境和龙门测试环境对应的配置文件分别为
      application-global.properties和application-lm.properties;别的抽取到resource公共资源文件夹下
      (需要协商讨论旧front中两个不同profile文件夹下不同之处？是否只是配置不同以及对应的xml和库内容是否相同？).
   8. 进行功能测试(由测试组进行功能联调测试).如果测试OK，进行下一步的改造，否则解决重构带来的问题. 
   9. 搭建RedisCluster集群。为项目配置WEB层一级缓存(配置Spring缓存的CacheManager，使其支持RedisCluster+Ehcache).
   10. 改用伪RPC调用。即梳理所有的接口代码，找出与外部通信的部分。由外部模块的种类进行分类，编写对应外部模块的RPC接口代码并整合熔断机制(Hystrix)
     (由于外部模块还未重构，需要配置对应外部服务的本地调用地址列表serverList).
   11. 引入微服务框架(协商使用SpringCloud或SpringCloudAlibaba);
       1. 先引入对应的注册中心(Nacos或Eureka).
       2. 引入路由网关配置(使用Zuul或者Gateway)，并整合对应的限流组件(RateLimiter)进行限流配置. 
       3. 配置当前项目，使其支持注册中心. 
   12. 进行压测，通过网关借助版本号路由配置进行灰度发布;
      
## (二期计划) 对其它外部模块重构，并纳入微服务
   1. 首先对历年可用性不高，容易出现问题的项目，例如chat和chat-dispatcher在原先的项目之上进行流程改造(例如使用消息机制将chat和dispatch
   之间的通信改为异步，Redis改为集群部署等);进行压测评估，单个引入限流组件进行限流配置, 先解决线上致命的问题。然后再新起项目进行重构.
   2. 重构的外层技术框架建议和front一样使用SpringMVC+springboot(原因是SpringMVC对以后的新招的开发人员比较友好，另外对服务间RPC通信框架支持比较好，配置
   简单且不易出现问题; 之所以建议springboot主要是因为springboot和微服务体系中的各个组价能实现无缝集成，其次是为了方便以后的开发配置以及运维)。重构的流程和
   front类似。
   3. 纳入微服务; 此过程和front重构的步骤10类似，先引入配置注册中心、RPC以及熔断器依赖,找出与外部通信的部分并编写对应的RPC接口代码且配置与RPC接口对应的本地serverList.
  
## (三期计划) 完善分布式架构 & 对项目进行模块拆分 & 服务编排部署
   1. 二期计划完毕之后，需要为每个项目选择合适的服务名(不可重复)。并去掉每个RPC接口对应的serverList(统一从注册中心获取).
   2. 以上就绪之后，开始完善分布式的管理; 
      1. 首先搭建并引入配置中心(综合比较进行选型: ConfigServer或Nacos或consul)且按照规则将每个项目的配置内容统一抽取到配置中心进行管理
   并结合消息总线(SpringCloudBus)实现配置的实时刷新. 
      2. 引入sleuth(zipkinServer)结合ELK以及ES进行链式追踪以及分布式日志的搜集.
      3. 因为引入了服务的多副本，可能会引起重复执行定时任务.需引入分布式任务调度组件进行统一改造.
      4. 在熟悉项目业务的基础上，需定位出整体结构中可以异步解耦的部分使用消息中间件交互(选型考虑使用CloudStream微服务消息规范还是基于AMQP协议的SpringCloudBus).
      5. 其次是进行流量评估; 对入口总流量以及通过每个项目的流量进行测试预估以确定每个项目需要扩容的副本数量.并在入口网关层进行统一配置进行细粒度的限流.
      6. 需额外开启微服务相关的监控(使用SpringBootAdmin整合监控界面); 例如对断路器的仪表盘、sleuth的界面、日志的界面以及注册中心的界面进行集中整合(方便问题定位排查).
   3. 以上重构流程彻底完成之后,可以考虑对每个项目进行模块拆分.(模块拆分的好处是对项目进行细粒度的的管理、从代码层面消除耦合、方便独立部署);拆分的原则如下：
      1. 按照项目中的业务功能模块进行拆分,需要将项目中流量大模块的拆开.
      2. 将容易出问题、外部通信较多的部分尽量拆分到一个服务中进行集中管理.
      3. 进行拆分后会产生很多公共的代码和类，需要单独抽取通用性高的代码独立出来(借助私服进行管理维护).
      4. 需要将service模块的功能移植拆分到不同的服务的service层中.
   4. 在步骤3之前或步骤3之后可以开始开始考虑微服务的编排部署问题了.
      1. 对于单个服务可以考虑使用maven插件或编写docker-file文件的方式来构建镜像.
      2. 需要梳理各个服务间的启动依赖和通信交互(决定了对应的服务是否能成功启动).
      3. 进行服务的编排. 考虑采用dockerSwarm还是K8S编写部署脚本来实现服务的整体部署以及单个部署.
      4. 安装Jenkins; 并安装项目运行所需要的的一系列插件(publish Over ssh，CVS，k8s插件等...); 创建job并结合服务服务编排脚本和构建策略来实现代码的实时构建.   

## (四期计划: 可选) 彻底替换持久层框架 & 代码优化，完善文档。
   1. 之所以将持久层的放到最后进行重构，是因为这块(例如cyou-dao)是所有项目都依赖的模块，代码封装层级较深，耦合性极高. 另外又单独封装了持久层的memcached缓存，复杂度高.
   2. 因为DAO层重用性比较高。不建议对它进行拆分，可以考虑使用mybatisPlus或JPA(推荐mybatisPlus).
      1. 推荐一种快速整合的方案.调用原始项目打印具体的SQL，优化后粘贴到对应的mapper.xml方法中。比较快速一点。
   3. 开启mybatis的缓存机制，去掉memcached缓存.
   4. 在dao模块上整合druid数据源，并配置对应的SQL监控(方便查找一些慢SQL进行优化).
   5. 整合与微服务集成的第三方分布式事务框架例如LCN等; 对一些严格要求一致性的业务模块调用例如支付，考虑在WEB层进行分布式事务注解配置来实现一致性.
   6. 搭建文档服务器(例如confluence); 导入每个微服务对应的接口文档(并添加接口功能描述),为了方便可以截取sleuth的调用链截图来充当调用时序图(但要添加对应的流程描述)
---
  总结：以上是对整体项目的大体计划(由于对项目的了解程度有限，在细节上有很多不完善的地方，后期在熟悉的过程中会逐步完善);
  - 其中一期计划是一次技术换代的尝试与实践,因为front中涉及的内容最多，所以需要先从它入手进行重构，将struts迁移MVC和Boot过程中遇到的问题都碰一遍，那么在二期对别的项目采用同样方式进行
    重构替换时遇到的问题就少了. (为二期别的项目趟趟雷).
  - 二期为了方便以后的开发以及微服务组件的集成(为三期打基础). 如果没有SpringMVC和springboot也可以纳入微服务进行重构，但是需要重写很多代码很麻烦而且如果开发者不深入研究对应组件源码的
    情况下容易留下致命隐患.
  - 前两期的重构都是为了第三期做铺垫，第三期的目的就是发挥微服务框架的优势来解决服务限流、动态扩容、问题定位查找、配置的统一管理和实时刷新等问题. 最重要是解决动态扩容、限流和负载均衡的问题.
  - 最后一期重构是可选的，因为代价太大。对持久层的重构主要是为了提升数据库的查询以及事务操作的效率，对一些SQL进行监控和优化;对这层进行重构相当于重写一套系统70%的工作量; 其实在三期重构完毕
    之后已经能通过牺牲硬件为代价承载相当高的并发量了;
  
    
   